<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Luvit documentation</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>Luvit</h1>

<ul>
  <li><a href="../index.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#uv_Handle">uv.Handle</a></li>
<li><a href="#uv_Pipe">uv.Pipe</a></li>
<li><a href="#uv_Process">uv.Process</a></li>
<li><a href="#uv_Stream">uv.Stream</a></li>
<li><a href="#uv_Tcp">uv.Tcp</a></li>
<li><a href="#uv_Timer">uv.Timer</a></li>
<li><a href="#uv_Tty">uv.Tty</a></li>
<li><a href="#uv_Udp">uv.Udp</a></li>
<li><a href="#uv_Watcher">uv.Watcher</a></li>
<li><a href="#net__Socket">net2.Socket</a></li>
<li><a href="#net__connect_port__host__connectListener_">net2.connect(port, host, connectListener)</a></li>
<li><a href="#net__createServer_options__connectionListener_">net2.createServer(options, connectionListener)</a></li>
</ul>


<h2>Topics</h2>
<ul>
  <li><a href="../topics/README.markdown.html">README.markdown</a></li>
  <li><strong>api.markdown</strong></li>
  <li><a href="../topics/docs.markdown.html">docs.markdown</a></li>
  <li><a href="../topics/errors.markdown.html">errors.markdown</a></li>
</ul>
<h2>Modules</h2>
<ul>
  <li><a href="../modules/luvit.buffer.html">luvit.buffer</a></li>
  <li><a href="../modules/luvit.childprocess.html">luvit.childprocess</a></li>
  <li><a href="../modules/luvit.http.html">luvit.http</a></li>
  <li><a href="../modules/luvit.querystring.html">luvit.querystring</a></li>
  <li><a href="../modules/luvit.url.html">luvit.url</a></li>
</ul>
<h2>Examples</h2>
<ul>
  <li><a href="../examples/buffer-basics.lua.html">buffer-basics.lua</a></li>
  <li><a href="../examples/child-execfile.lua.html">child-execfile.lua</a></li>
  <li><a href="../examples/child-spawn.lua.html">child-spawn.lua</a></li>
  <li><a href="../examples/http-client.lua.html">http-client.lua</a></li>
  <li><a href="../examples/http-server.lua.html">http-server.lua</a></li>
</ul>

</div>

<div id="content">

<h1>Topic <code>api.markdown</code></h1>


<h2>uv</h2>

<p>Inherits from <code>core.Object</code></p>

<p><a name="uv_Handle"></a></p>
<h3>uv.Handle</h3>

<p>Inherits from <code>Emitter</code></p>

<p>This class is never used directly, but is the inheritance chain of all libuv
objects.</p>

<h4>Handle:addHandlerType(name)</h4>

<p>This is used by Emitters to register with native events when the first listener
is added.</p>

<p><a name="uv_Pipe"></a></p>
<h3>uv.Pipe</h3>

<p>Inherits from <code>uv.Stream</code></p>

<h4>Pipe:initialize(ipc)</h4>

<p><a name="uv_Process"></a></p>
<h3>uv.Process</h3>

<p>Inherits from <code>uv.Handle</code></p>

<h4>Process:initialize(command, args, options)</h4>

<p><a name="uv_Stream"></a></p>
<h3>uv.Stream</h3>

<p>Inherits from <code>uv.Handle</code></p>

<p>This is never used directly.  If you want to create a pure Lua stream, subclass
or instantiate <code>core.iStream</code>.</p>

<p><a name="uv_Tcp"></a></p>
<h3>uv.Tcp</h3>

<p>Inherits from <code>uv.Stream</code></p>

<h4>Tcp:initialize()</h4>

<p><a name="uv_Timer"></a></p>
<h3>uv.Timer</h3>

<p>Inherits from <code>uv.Handle</code></p>

<h4>Timer:initialize()</h4>

<p><a name="uv_Tty"></a></p>
<h3>uv.Tty</h3>

<p>Inherits from <code>uv.Stream</code></p>

<h4>Tty:initialize(fd, readable)</h4>

<p><a name="uv_Udp"></a></p>
<h3>uv.Udp</h3>

<p>Inherits from <code>uv.Handle</code></p>

<h4>Udp:initialize()</h4>

<p><a name="uv_Watcher"></a></p>
<h3>uv.Watcher</h3>

<p>Inherits from <code>uv.Handle</code></p>

<h4>Watcher:initialize(path)</h4>

<p>istening'` event has been emitted.</p>

<h4>Server:close()</h4>

<p>Stops the server from accepting new connections. This function is
asynchronous, the server is finally closed when the server emits a <code>'close'</code>
event.</p>

<h4>Server:listen(port, host, listeningListener)</h4>

<p>Begin accepting connections on the specified <code>port</code> and <code>host</code>.  If the
<code>host</code> is omitted, the server will accept connections directed to any
IPv4 address (<code>INADDR_ANY</code>). A port value of zero will assign a random port.</p>

<p>This function is asynchronous.  When the server has been bound,
<a href="#event_listening_">'listening'</a> event will be emitted.
the last parameter <code>listeningListener</code> will be added as an listener for the
<a href="#event_listening_">'listening'</a> event.</p>

<p>One issue some users run into is getting <code>EADDRINUSE</code> errors. This means that
another server is already running on the requested port. One way of handling this
would be to wait a second and then try again. This can be done with</p>


<pre>
 server:on(<span class="string">'error'</span>, <span class="keyword">function</span> (e)
   <span class="keyword">if</span> e.code == <span class="string">'EADDRINUSE'</span> <span class="keyword">then</span>
     <span class="global">print</span>(<span class="string">'Address in use, retrying...'</span>)
     timer.setTimeout(<span class="number">1000</span>, <span class="keyword">function</span> ()
       server:close()
       server:listen(PORT, HOST)
     <span class="keyword">end</span>)
   <span class="keyword">end</span>
 <span class="keyword">end</span>)
</pre>

<p>(Note: All sockets in Luvit set <code>SO_REUSEADDR</code> already)</p>

<p>If a path is given instead of a port, then start a UNIX socket server
listening for connections on the given <code>path</code>.</p>

<p>This function is asynchronous.  When the server has been bound,
<a href="#event_listening_">'listening'</a> event will be emitted.
the last parameter <code>listeningListener</code> will be added as an listener for the
<a href="#event_listening_">'listening'</a> event.</p>


<h4>Server:pause(msecs)</h4>

<p>Stop accepting connections for the given number of milliseconds (default is
one second).  This could be useful for throttling new connections against
DoS attacks or other oversubscription.</p>

<p><a name="net__Socket"></a></p>
<h3>net2.Socket</h3>

<p>Inherits from <code>uv.Stream</code></p>

<p>This object is an abstraction of a TCP or UNIX socket.  <code>net.Socket</code>
instances implement a duplex Stream interface.  They can be created by the
user and used as a client (with <code>connect()</code>) or they can be created by Luvit
and passed to the user through the <code>'connection'</code> event of a server.</p>

<h4>Socket:address()</h4>

<p>Returns the bound address and port of the socket as reported by the operating
system. Returns a table with two properties, e.g.
<code>{address = "192.168.57.1", port = 62053}</code></p>

<h4>Socket:connect(port, host, connectListener)</h4>

<p>Opens the connection for a given socket. If <code>port</code> and <code>host</code> are given,
then the socket will be opened as a TCP socket, if <code>host</code> is omitted,
<code>localhost</code> will be assumed. If a <code>path</code> is given, the socket will be
opened as a unix socket to that path.</p>

<p>Normally this method is not needed, as <code>net.createConnection</code> opens the
socket. Use this only if you are implementing a custom Socket or if a
Socket is closed and you want to reuse it to connect to another server.</p>

<p>This function is asynchronous. When the <a href="#event_connect_">'connect'</a> event is
emitted the socket is established. If there is a problem connecting, the
<code>'connect'</code> event will not be emitted, the <code>'error'</code> event will be emitted with
the exception.</p>

<p>The <code>connectListener</code> parameter will be added as an listener for the
<a href="#event_connect_">'connect'</a> event.</p>

<h4>Socket:destroy()</h4>

<p>Ensures that no more I/O activity happens on this socket. Only necessary in
case of errors (parse error or so).</p>

<h4>Socket:finish(data, callback)</h4>

<p>Half-closes the socket. i.e., it sends a FIN packet. It is possible the
server will still send some data.</p>

<p>If <code>data</code> is specified, it is equivalent to calling
<code>socket:write(data)</code> followed by <code>socket:finish()</code>.</p>

<h4>Socket:initialize(options)</h4>

<p>Construct a new socket object.</p>

<p><code>options</code> is an object with the following defaults:</p>


<pre>
 {
   fd = <span class="keyword">nil</span>,
   <span class="global">type</span> = <span class="keyword">nil</span>,
   allowHalfOpen = <span class="keyword">false</span>
 }
</pre>

<p><code>fd</code> allows you to specify the existing file descriptor of socket. <a href="http://www.lua.org/manual/5.1/manual.html#pdf-type">type</a>
specified underlying protocol. It can be <code>'tcp4'</code>, <code>'tcp6'</code>, or <code>'unix'</code>.
About <code>allowHalfOpen</code>, refer to <code>createServer()</code> and <code>'end'</code> event.</p>

<h4>Socket:pause()</h4>

<p>Pauses the reading of data. That is, <code>'data'</code> events will not be emitted.
Useful to throttle back an upload.</p>

<h4>Socket:remoteAddress()</h4>

<p>The string representation of the remote IP address. For example,
<code>'74.125.127.100'</code> or <code>'2001:4860:a005::68'</code>.</p>

<h4>Socket:remotePort()</h4>

<p>The numeric representation of the remote port. For example,
<code>80</code> or <code>21</code>.</p>

<h4>Socket:resume()</h4>

<p>Resumes reading after a call to <code>pause()</code>.</p>

<h4>Socket:setKeepAlive(enable, initialDelay)</h4>

<p>Enable/disable keep-alive functionality, and optionally set the initial
delay before the first keepalive probe is sent on an idle socket.
<code>enable</code> defaults to <code>false</code>.</p>

<p>Set <code>initialDelay</code> (in milliseconds) to set the delay between the last
data packet received and the first keepalive probe. Setting 0 for
initialDelay will leave the value unchanged from the default
(or previous) setting. Defaults to <code>0</code>.</p>

<h4>Socket:setNoDelay(noDelay)</h4>

<p>Disables the Nagle algorithm. By default TCP connections use the Nagle
algorithm, they buffer data before sending it off. Setting <code>true</code> for
<code>noDelay</code> will immediately fire off data each time <code>socket.write()</code> is called.
<code>noDelay</code> defaults to <code>true</code>.</p>

<h4>Socket:setTimeout(timeout, callback)</h4>

<p>Sets the socket to timeout after <code>timeout</code> milliseconds of inactivity on
the socket. By default <code>net.Socket</code> do not have a timeout.</p>

<p>When an idle timeout is triggered the socket will receive a <code>'timeout'</code>
event but the connection will not be severed. The user must manually <code>end()</code>
or <code>destroy()</code> the socket.</p>

<p>If <code>timeout</code> is 0, then the existing idle timeout is disabled.</p>

<p>The optional <code>callback</code> parameter will be added as a one time listener for the
<code>'timeout'</code> event.</p>

<h4>Socket:write(data, callback)</h4>

<p>Sends data on the socket. The second parameter specifies the encoding in the
case of a string--it defaults to UTF8 encoding.</p>

<p>Returns <code>true</code> if the entire data was flushed successfully to the kernel
buffer. Returns <code>false</code> if all or part of the data was queued in user memory.
<code>'drain'</code> will be emitted when the buffer is again free.</p>

<p>The optional <code>callback</code> parameter will be executed when the data is finally
written out - this may not be immediately.</p>

<p><a name="net__connect_port__host__connectListener_"></a></p>
<h3>net2.connect(port, host, connectListener)</h3>

<p>Construct a new socket object and opens a socket to the given location. When the
socket is established the <code>connect</code> event will be emitted.</p>

<p>The arguments for these methods change the type of connection:</p>

<ul>
    <li><p><code>net.connect(port, [host], [connectListener])</code> - Creates a TCP connection to
    port on host. If host is omitted, 'localhost' will be assumed.</p></li>
    <li><p><code>net.connect(path, [connectListener])</code> - Creates unix socket connection to
    <code>path</code>.</p></li>
</ul>

<p>The connectListener parameter will be added as an listener for the <code>connect</code>
event.</p>

<p>Here is an example of a client of echo server as described previously:</p>


<pre>
 <span class="keyword">local</span> net = <span class="global">require</span> <span class="string">'net'</span>
 <span class="keyword">local</span> client = net.connect(<span class="number">8124</span>, <span class="keyword">function</span> ()
   <span class="global">debug</span>(<span class="string">'on_connect'</span>)
   client:write(<span class="string">'world!\r\n'</span>)
 <span class="keyword">end</span>)
 client:on(<span class="string">'data'</span>, <span class="keyword">function</span> (data)
   <span class="global">debug</span>(<span class="string">'on_data'</span>, data)
   client:<span class="keyword">end</span>()
 <span class="keyword">end</span>)
 client:on(<span class="string">'end'</span>, <span class="keyword">function</span> ()
   <span class="global">debug</span>(<span class="string">'on_end'</span>)
 <span class="keyword">end</span>)
</pre>

<p>To connect on the socket <code>/tmp/echo.sock</code> the second line would just be changed to</p>


<pre>
 <span class="keyword">local</span> client = net.connect(<span class="string">'/tmp/echo.sock'</span>, <span class="keyword">function</span> ()
</pre>

<p><a name="net__createServer_options__connectionListener_"></a></p>
<h3>net2.createServer(options, connectionListener)</h3>

<p>Creates a new TCP server. The <code>connectionListener</code> argument is automatically set
as a listener for the <code>connection</code> event.</p>

<p><code>options</code> is a table with the following defaults:</p>


<pre>
 { allowHalfOpen = <span class="keyword">false</span> }
</pre>

<p>If <code>allowHalfOpen</code> is <code>true</code>, then the socket won't automatically send a FIN
packet when the other end of the socket sends a FIN packet. The socket becomes
non-readable, but still writable. You should call the <code>end()</code> method explicitly.
See <code>end</code> event for more information.</p>

<p>Here is an example of a echo server which listens for connections
on port 8124:</p>


<pre>
 <span class="keyword">local</span> net = <span class="global">require</span>(<span class="string">'net'</span>)
 <span class="keyword">local</span> server = net.createServer(<span class="keyword">function</span> (c)  <span class="comment">-- 'connection' listener
</span>   <span class="global">debug</span>(<span class="string">'server connected'</span>)
   c:on(<span class="string">'end'</span>, <span class="keyword">function</span> ()
     <span class="global">debug</span>(<span class="string">'client disconnected'</span>)
   <span class="keyword">end</span>)
   c:write(<span class="string">'hello\r\n'</span>)
   c:pipe(c)
 <span class="keyword">end</span>)
 server:listen(<span class="number">8124</span>, <span class="keyword">function</span> ()
   <span class="global">print</span>(<span class="string">'server bound'</span>)
 <span class="keyword">end</span>)
</pre>

<p>Test this by using <code>telnet</code>:</p>


<pre>
 telnet localhost <span class="number">8124</span>
</pre>

<p>To listen on the socket <code>/tmp/echo.sock</code> the third line from the last would
just be changed to</p>


<pre>
 server:listen(<span class="string">'/tmp/echo.sock'</span>, <span class="keyword">function</span> (c) {
</pre>

<p>Use <code>nc</code> to connect to a UNIX domain socket server:</p>


<pre>
 nc -U /tmp/echo.sock
</pre>



</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.2</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
